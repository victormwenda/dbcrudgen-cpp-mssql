#ifndef ${PROJECT_NAME}_${CLASS_NAME_HEADER}_H
#define ${PROJECT_NAME}_${CLASS_NAME_HEADER}_H

#include <cppconn/driver.h>

class MYSQLDatabaseConnector {

private:
    sql::Driver *driver;
    sql::Connection *connection;

public:
    MYSQLDatabaseConnector() {
        driver = get_driver_instance();
        connection = nullptr;
    }

    /**
     * Open connection
     * @param hostname
     * @param username
     * @param password
     * @return
     */
    sql::Connection *openConnection(const std::string &hostname, const std::string &username,
                                    const std::string &password) {
        connection = driver->connect(hostname, username, password);
    }

    /**
     * Check if there is a database connection
     * @return
     */
    bool isOpen() {
        return connection->isValid();
    }

    sql::Statement *createStatement() {
        return connection->createStatement();
    }

    bool getAutoCommit() {
        return connection->getAutoCommit();
    }

    void enableAutoCommit() {
        setAutoCommit(true);
    }

    void disableAutoCommit() { setAutoCommit(false); }

    void setAutoCommit(bool autoCommit) {
        connection->setAutoCommit(autoCommit);
    }

    void clearWarnings() { connection->clearWarnings(); }

    void commit() { return connection->commit(); }

    std::string getCatalog() {
        return connection->getCatalog();
    }

    std::string getClientInfo() { return connection->getClientInfo(); }

    std::string getClientOption(const std::string &optionName) {
        return connection->getClientOption(optionName);
    }

    std::string getClientOption(const std::string &optionName, void *optionValue) {
        connection->getClientOption(optionName, optionValue);
    }

    std::string setClientOption(const std::string &optionName, const std::string &optionValue) {
        connection->setClientOption(optionName, optionValue);
    }

    std::string setClientOption(const std::string &optionName, void *optionValue) {
        connection->setClientOption(optionName, optionValue);
    }

    sql::DatabaseMetaData *getDatabaseMetadata() { return connection->getMetaData(); }

    void nativeSQL(const std::string &rawSQL) {
        connection->nativeSQL(rawSQL);
    }

    void prepareStatement(std::string sql) { connection->prepareStatement(sql); };

    void prepareStatement(std::string sql, int autoGeneratedKeys) {
        connection->prepareStatement(sql, autoGeneratedKeys);
    };

    void prepareStatement(std::string sql, int *columnIndexes) { connection->prepareStatement(sql, columnIndexes); };

    void prepareStatement(std::string sql, int resultSetType, int resultSetConcurrency) {
        connection->prepareStatement(sql, resultSetType, resultSetConcurrency);
    };

    void prepareStatement(std::string sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) {
        connection->prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    };

    void prepareStatement(std::string sql, std::string columnNames) {
        sql::SQLString columnNamesPtr = sql::SQLString{columnNames};
        connection->prepareStatement(sql, &columnNamesPtr);
    };


    void setReadOnly(bool readOnly) {
        connection->setReadOnly(readOnly);
    }

    void setHoldability(int holdability) {
        connection->setHoldability(holdability);
    }

    void releaseSavePoint(sql::Savepoint &savepoint) {
        connection->releaseSavepoint(&savepoint);
    }

    void rollback() {
        connection->rollback();

    }

    void rollback(sql::Savepoint &savepoint) {
        connection->rollback(&savepoint);
    }

    void setSavePoint() { connection->setSavepoint(); }

    void setSavePoint(const std::string &name) {
        connection->setSavepoint(name);
    }

    void setSchema(const std::string &schema) {
        connection->setSchema(schema);
    }


    void setTransactionIsolation(sql::transaction_isolation isolation) {
        connection->setTransactionIsolation(isolation);
    }

    /**
     * Close database connection
     * @return
     */
    bool close() {
        connection->close();

        return !isOpen();

    }

    /**
     * Auto close connection when out of scope
     */
    ~MYSQLDatabaseConnector() {
        if (isOpen()) close();
    }
};

#endif //${PROJECT_NAME}_${CLASS_NAME_HEADER}_H